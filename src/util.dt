(module util)

(import stdlib)
(import macros)
(import concepts)
(import cstdlib)

#|
@macro mexit

Stops the compiliation of program.
Useful for debug reasons, when you know some error appears before this macro is expanded.

|#
(using-namespace std
(def mexit (macro extern (void)
  (exit 1)
  (q 0)))
)




(using-namespace std.macros

(def when (macro extern (con rest)
  (def list (var auto \ (get-varargs-list mc (- (arg-count mc) 1) rest)))
  (qq if (uq con) (do (uql list)) false)))

(def unless (macro extern (con rest)
  (def list (var auto \ (get-varargs-list mc (- (arg-count mc) 1) rest)))
  (qq if (uq con) false (do (uql list)))))

(def apply-list
  (fn (attr cto) extern (p DNode)
      ((mc (p MContext))
       (list (p DNode))
       (data (p void))
       (fun (p (fn (p DNode) ((mc (p MContext))
                              (node (p DNode))
                              (data (p void)))))))
    (let ((elt \ (fun mc list data)))
      (if (not (null (@:@ list next-node)))
        (let ((rest \ (@:@ (apply-list mc (@:@ list next-node) data fun) list-node)))
          (qq (uq elt) (uql rest)))
        (qq (uq elt))))))


(def arg-list-names (fn (attr cto) extern (p DNode) ((mc (p MContext)) (form (p DNode)))
  (unless (= 0 (@:@ form is-list))
    (when (p= (@:@ form list-node) (q void))
      (printf "defc-void\n")
      (return (make-node mc))))
  (let ((list \
         (apply-list mc (@:@ form list-node) (nullptr void)
           (fn (attr cto) (p DNode) ((mc (p MContext)) (form (p DNode)) (data (p void)))
             (if (= 0 (@:@ form is-list))
               form
               (@:@ form list-node))))))
    (@:@ list list-node))))


(def defc (macro extern (name linkage cname type args)
  (let ((arg-list \ (arg-list-names mc args))
        (fdef \ (qq (uq cname) (uql-nc arg-list))))
    (qq do
      (def (uq cname) (fn extern-c (uq type) (uq args)))
      (def (uq name) (fn (uq linkage) (uq type) (uq args)
        ((uq cname) (uql arg-list))))))))

(ignore def defc (macro extern (name linkage cname type)
  (let ((fdef \ (qq (uq cname))))
    (qq do
      (def (uq cname) (fn extern-c (uq type) (uq args)))
      (def (uq name) (fn (uq linkage) (uq type) (uq args)
        ((uq cname) (uql arg-list))))))))



(def defc-multi (macro extern (name linkage def0 rest)
  (qq do
    (defc (uq name) (uq linkage) (uql def0))
    (defc-multi (uq name) (uq linkage) (get-varargs-list (- (arg-count mc) 3) rest)))))

(def defc-multi (macro extern (name linkage)
  (qq no-op)))



(def pow (macro extern (x (n int))
    (def n0 (var auto int))
    (if (eval-expression mc (q int) n (cast (# n0) (p void)))
        (do (if (= n0 1) x
                (let ((n1 \ (- n0 1))
                      (nn \ (mnfv mc n1)))
                  (if (is-lvalue mc x)
                    (qq * (uq x) (pow (uq x) (uq nn)))
                    (let ((tmp \ (make-gensym-var-node mc)))
                      (qq let (((uq tmp) \ (uq x)))
                        (* (uq tmp) (pow (uq tmp) (uq nn)))))))))
        (do (report-error mc n "unable to evaluate\n") (qq no-op)))))

(def is-zero (fn extern bool ((a float))
  (= a 0.0)))

(def is-zero (fn extern bool ((a double))
  (= a (cast 0.0 double))))

(def is-zero (fn extern bool ((a long-double))
  (= a (cast 0.0 long-double))))


(def /0 (macro extern (x y)
  (qq if (is-zero (uq y))
    (* (uq x) (uq y))
    (/ (uq x) (uq y)))))


(def in (macro extern (name value rest)
  (let ((list \ (get-varargs-list mc (- (arg-count mc) 2) rest))
        (en \ (make-gensym-var-node mc))
        (bn \ (make-gensym-var-node mc)))
    (if (is-lvalue mc value)
      (qq for (((uq bn) \ (begin (uq value))) ((uq en) \ (end (uq value))))
              (< (uq bn) (uq en))
              (setv (uq bn) (successor (uq bn)))
        (let (((uq name) \ (source (uq bn))))
          (uql list)))
      (let ((val \ (make-gensym-var-node mc)))
        (qq let (((uq val) \ (uq value)))
          (in (uq name) (uq val) (uql list))))))))



(def def-type-macro2
  (macro extern (name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (qq do
          (def (uq name)
            (macro extern (T U)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
                n))))))))

(def def-type-macro3
  (macro extern (name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (qq do
          (def (uq name)
            (macro extern (T U V)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U V typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
                n))))))))

(ignore def def-type-macro2
  (macro extern (macro-name name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (qq do
          (def (uq macro-name)
            (macro extern (T U)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
                n))))))))

(ignore def as-macro (macro extern (rest)
  (let ((macro-name \ (make-gensym-var-node mc)))
    (qq do
      (def (uq macro-name) (macro extern (void)
        (uql (get-varargs-list mc (arg-count mc) rest))))
      ((uq macro-name))))))

(ignore def make-type-node
  (fn extern (p DNode) ((mc (p MContext)) (name (p DNode)) (T (p DNode)) (U (p DNode)))
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (qq do
          (as-macro
            (let ((typename (array-of 250 char)))
              (and (not (make-type-string mc (uq string) (q (uq T)) (q (uq U)) typename))
                   (return T))
              (def n (var auto (p DNode) (mnfv mc typename)))
              n)))))))


(ignore using-namespace std.concepts
(def def-type-macro2+
  (macro extern (name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (qq do
          (def (uq name)
            (macro extern (T U)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
                (if (exists-type mc typename)
                    n
                    (qq do
                      (instantiate (uq (uq name)) (uq (uq T)) (uq (uq U)))
                      (uq n)))))))))))
)

(def def-ptr-macro (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value (p (uq type))))
      (qq (uq name) (@ (uq (uq value)))))))))

(def def-ptr-macro2 (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value1 (p (uq type))) (value2 (p (uq type))))
      (qq (uq name) (@ (uq (uq value1))) (@ (uq (uq value2)))))))))

(def macro-print (macro extern (object)
  (print object)
  (printf "\n")
  (qq no-op)))

  (def make-list (macro extern (a)
    (qq (uq a))))

  (def make-list (macro extern (a rest)
    (let ((list \ (get-varargs-list mc (- (arg-count mc) 1) rest)))
      (qq (uq a) (make-list (uql list))))))

  (ignore def range-fn (fn (attr cto) extern (p DNode) ((mc (p MContext)) (a (p DNode)) (b (p DNode)))
    (let ((x int)
          (y int))
      (eval-expression mc (q int) a (cast (# x) (p void)))
      (eval-expression mc (q int) b (cast (# y) (p void)))
        (if (< x y)
          (qq (uq a) (uql (@:@ (range-fn mc (mnfv mc (+ x 1)) b) list-node)))
          (qq (uq a))))))

  (ignore def range (macro extern (a b)
    (range-fn mc a b)))


(def incf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (+ (@ (uq pos)) (uq res)))))))

(def decf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (- (@ (uq pos)) (uq res)))))))

(def mulf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (* (@ (uq pos)) (uq res)))))))

(def divf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (/ (@ (uq pos)) (uq res)))))))

(def over (fn extern (retval int) ((n int) (k int))
  (setf retval 1)
  (for (i int 1) (< i k) (incv i)
    (mulf retval (/ (- (+ n 1) i) i)))))


(import operator-macros)
(def-left-associative-macro @$' extern @$)

(ignore def my-make-list (fn (attr cto) intern (p DNode) ((mc MContext) (list (p DNode)))
  (let ((list-node (p DNode) list))
    (and (!= (@:@ list is-list) 0)
       (setv list-node (@:@ list list-node)))
    (qq (uq list-node) (uql (@:@ (my-make-list (@:@ list next-node)) list-node))))))

(def with-slots-tmp (var intern (p DNode)))

(ignore def with-slots (macro extern (list value rest)
  (setv with-slots-tmp (make-gensym-var-node mc))
  (if (is-lvalue mc value)
    (do (report-error mc value "`with-slots` currently only works with rvalues") (qq no-op))
    (qq let (((uq with-slots-tmp) \ (uq value)))
      (let (uq (apply-list mc list (nullptr void)
        (fn (attr cto) (p DNode) ((mc (p MContext)) (node (p DNode)) (data (p void)))
          (qq (uq node) \ (@: (uq with-slots-tmp) val))))))))))

(ignore def test (fn intern void (void)
  (with-slots (a b c) n
    (* a b))))
;(mexit)
(ignore using-namespace std.concepts
(def + (macro extern (a b)
  (let ((A \ (type-of mc a false))
        (B \ (type-of mc b false)))
      (ignore when (= A B)
        (report-error mc "For + both types should be the same")
        (return (qq no-op)))
      (qq using-namespace std.concepts
        (when (exists-concept +)
          (instantiate + (uq A)))
        (if (exists-fn (uq A) + (uq A) (uq A))
          (as-macro (qq + (uq a) (uq b)))
          (as-macro (qq no-op)))))))
)
)



